{"ast":null,"code":"/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox-precaching\n */\n\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] The cache to use for precaching.\n   * @param {string} [options.plugins] Plugins to use when precaching as well\n   * as responding to fetch events for precached assets.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  constructor() {\n    let {\n      cacheName,\n      plugins = [],\n      fallbackToNetwork = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._urlsToCacheKeys = new Map();\n    this._urlsToCacheModes = new Map();\n    this._cacheKeysToIntegrities = new Map();\n    this._strategy = new PrecacheStrategy({\n      cacheName: cacheNames.getPrecacheName(cacheName),\n      plugins: [...plugins, new PrecacheCacheKeyPlugin({\n        precacheController: this\n      })],\n      fallbackToNetwork\n    }); // Bind the install and activate methods to the instance.\n\n    this.install = this.install.bind(this);\n    this.activate = this.activate.bind(this);\n  }\n  /**\n   * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n   * used to cache assets and respond to fetch events.\n   */\n\n\n  get strategy() {\n    return this._strategy;\n  }\n  /**\n   * Adds items to the precache list, removing any duplicates and\n   * stores the files in the\n   * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n   * worker installs.\n   *\n   * This method can be called multiple times.\n   *\n   * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n   */\n\n\n  precache(entries) {\n    this.addToCacheList(entries);\n\n    if (!this._installAndActiveListenersAdded) {\n      self.addEventListener('install', this.install);\n      self.addEventListener('activate', this.activate);\n      this._installAndActiveListenersAdded = true;\n    }\n  }\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n   *     Array of entries to precache.\n   */\n\n\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries'\n      });\n    }\n\n    const urlsToWarnAbout = [];\n\n    for (const entry of entries) {\n      // See https://github.com/GoogleChrome/workbox/issues/2259\n      if (typeof entry === 'string') {\n        urlsToWarnAbout.push(entry);\n      } else if (entry && entry.revision === undefined) {\n        urlsToWarnAbout.push(entry.url);\n      }\n\n      const {\n        cacheKey,\n        url\n      } = createCacheKey(entry);\n      const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n\n      if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey\n        });\n      }\n\n      if (typeof entry !== 'string' && entry.integrity) {\n        if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n          throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n            url\n          });\n        }\n\n        this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n      }\n\n      this._urlsToCacheKeys.set(url, cacheKey);\n\n      this._urlsToCacheModes.set(url, cacheMode);\n\n      if (urlsToWarnAbout.length > 0) {\n        const warningMessage = \"Workbox is precaching URLs without revision \" + \"info: \".concat(urlsToWarnAbout.join(', '), \"\\nThis is generally NOT safe. \") + \"Learn more at https://bit.ly/wb-precache\";\n\n        if (process.env.NODE_ENV === 'production') {\n          // Use console directly to display this warning without bloating\n          // bundle sizes by pulling in all of the logger codebase in prod.\n          console.warn(warningMessage);\n        } else {\n          logger.warn(warningMessage);\n        }\n      }\n    }\n  }\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * Note: this method calls `event.waitUntil()` for you, so you do not need\n   * to call it yourself in your event handlers.\n   *\n   * @param {ExtendableEvent} event\n   * @return {Promise<workbox-precaching.InstallResult>}\n   */\n\n\n  install(event) {\n    // waitUntil returns Promise<any>\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return waitUntil(event, async () => {\n      const installReportPlugin = new PrecacheInstallReportPlugin();\n      this.strategy.plugins.push(installReportPlugin); // Cache entries one at a time.\n      // See https://github.com/GoogleChrome/workbox/issues/2528\n\n      for (const [url, cacheKey] of this._urlsToCacheKeys) {\n        const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n\n        const cacheMode = this._urlsToCacheModes.get(url);\n\n        const request = new Request(url, {\n          integrity,\n          cache: cacheMode,\n          credentials: 'same-origin'\n        });\n        await Promise.all(this.strategy.handleAll({\n          params: {\n            cacheKey\n          },\n          request,\n          event\n        }));\n      }\n\n      const {\n        updatedURLs,\n        notUpdatedURLs\n      } = installReportPlugin;\n\n      if (process.env.NODE_ENV !== 'production') {\n        printInstallDetails(updatedURLs, notUpdatedURLs);\n      }\n\n      return {\n        updatedURLs,\n        notUpdatedURLs\n      };\n    });\n  }\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * Note: this method calls `event.waitUntil()` for you, so you do not need\n   * to call it yourself in your event handlers.\n   *\n   * @param {ExtendableEvent} event\n   * @return {Promise<workbox-precaching.CleanupResult>}\n   */\n\n\n  activate(event) {\n    // waitUntil returns Promise<any>\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return waitUntil(event, async () => {\n      const cache = await self.caches.open(this.strategy.cacheName);\n      const currentlyCachedRequests = await cache.keys();\n      const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n      const deletedURLs = [];\n\n      for (const request of currentlyCachedRequests) {\n        if (!expectedCacheKeys.has(request.url)) {\n          await cache.delete(request);\n          deletedURLs.push(request.url);\n        }\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        printCleanupDetails(deletedURLs);\n      }\n\n      return {\n        deletedURLs\n      };\n    });\n  }\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n\n\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n\n\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n\n\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location.href);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n  /**\n   * @param {string} url A cache key whose SRI you want to look up.\n   * @return {string} The subresource integrity associated with the cache key,\n   * or undefined if it's not set.\n   */\n\n\n  getIntegrityForCacheKey(cacheKey) {\n    return this._cacheKeysToIntegrities.get(cacheKey);\n  }\n  /**\n   * This acts as a drop-in replacement for\n   * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n   * with the following differences:\n   *\n   * - It knows what the name of the precache is, and only checks in that cache.\n   * - It allows you to pass in an \"original\" URL without versioning parameters,\n   * and it will automatically look up the correct cache key for the currently\n   * active revision of that URL.\n   *\n   * E.g., `matchPrecache('index.html')` will find the correct precached\n   * response for the currently active service worker, even if the actual cache\n   * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n   *\n   * @param {string|Request} request The key (without revisioning parameters)\n   * to look up in the precache.\n   * @return {Promise<Response|undefined>}\n   */\n\n\n  async matchPrecache(request) {\n    const url = request instanceof Request ? request.url : request;\n    const cacheKey = this.getCacheKeyForURL(url);\n\n    if (cacheKey) {\n      const cache = await self.caches.open(this.strategy.cacheName);\n      return cache.match(cacheKey);\n    }\n\n    return undefined;\n  }\n  /**\n   * Returns a function that looks up `url` in the precache (taking into\n   * account revision information), and returns the corresponding `Response`.\n   *\n   * @param {string} url The precached URL which will be used to lookup the\n   * `Response`.\n   * @return {workbox-routing~handlerCallback}\n   */\n\n\n  createHandlerBoundToURL(url) {\n    const cacheKey = this.getCacheKeyForURL(url);\n\n    if (!cacheKey) {\n      throw new WorkboxError('non-precached-url', {\n        url\n      });\n    }\n\n    return options => {\n      options.request = new Request(url);\n      options.params = Object.assign({\n        cacheKey\n      }, options.params);\n      return this.strategy.handle(options);\n    };\n  }\n\n}\n\nexport { PrecacheController };","map":{"version":3,"names":["assert","cacheNames","logger","WorkboxError","waitUntil","createCacheKey","PrecacheInstallReportPlugin","PrecacheCacheKeyPlugin","printCleanupDetails","printInstallDetails","PrecacheStrategy","PrecacheController","constructor","cacheName","plugins","fallbackToNetwork","_urlsToCacheKeys","Map","_urlsToCacheModes","_cacheKeysToIntegrities","_strategy","getPrecacheName","precacheController","install","bind","activate","strategy","precache","entries","addToCacheList","_installAndActiveListenersAdded","self","addEventListener","process","env","NODE_ENV","isArray","moduleName","className","funcName","paramName","urlsToWarnAbout","entry","push","revision","undefined","url","cacheKey","cacheMode","has","get","firstEntry","secondEntry","integrity","set","length","warningMessage","join","console","warn","event","installReportPlugin","request","Request","cache","credentials","Promise","all","handleAll","params","updatedURLs","notUpdatedURLs","caches","open","currentlyCachedRequests","keys","expectedCacheKeys","Set","values","deletedURLs","delete","getURLsToCacheKeys","getCachedURLs","getCacheKeyForURL","urlObject","URL","location","href","getIntegrityForCacheKey","matchPrecache","match","createHandlerBoundToURL","options","Object","assign","handle"],"sources":["C:/Users/omkar/OneDrive/Pictures/Desktop/weather/weather-app-reactjs/node_modules/workbox-precaching/PrecacheController.js"],"sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox-precaching\n */\nclass PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] The cache to use for precaching.\n     * @param {string} [options.plugins] Plugins to use when precaching as well\n     * as responding to fetch events for precached assets.\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n     * get the response from the network if there's a precache miss.\n     */\n    constructor({ cacheName, plugins = [], fallbackToNetwork = true, } = {}) {\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n        this._strategy = new PrecacheStrategy({\n            cacheName: cacheNames.getPrecacheName(cacheName),\n            plugins: [\n                ...plugins,\n                new PrecacheCacheKeyPlugin({ precacheController: this }),\n            ],\n            fallbackToNetwork,\n        });\n        // Bind the install and activate methods to the instance.\n        this.install = this.install.bind(this);\n        this.activate = this.activate.bind(this);\n    }\n    /**\n     * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n     * used to cache assets and respond to fetch events.\n     */\n    get strategy() {\n        return this._strategy;\n    }\n    /**\n     * Adds items to the precache list, removing any duplicates and\n     * stores the files in the\n     * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n     * worker installs.\n     *\n     * This method can be called multiple times.\n     *\n     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n     */\n    precache(entries) {\n        this.addToCacheList(entries);\n        if (!this._installAndActiveListenersAdded) {\n            self.addEventListener('install', this.install);\n            self.addEventListener('activate', this.activate);\n            this._installAndActiveListenersAdded = true;\n        }\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n     *     Array of entries to precache.\n     */\n    addToCacheList(entries) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isArray(entries, {\n                moduleName: 'workbox-precaching',\n                className: 'PrecacheController',\n                funcName: 'addToCacheList',\n                paramName: 'entries',\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n            // See https://github.com/GoogleChrome/workbox/issues/2259\n            if (typeof entry === 'string') {\n                urlsToWarnAbout.push(entry);\n            }\n            else if (entry && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n            if (this._urlsToCacheKeys.has(url) &&\n                this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey,\n                });\n            }\n            if (typeof entry !== 'string' && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) &&\n                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                        url,\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Workbox is precaching URLs without revision ` +\n                    `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` +\n                    `Learn more at https://bit.ly/wb-precache`;\n                if (process.env.NODE_ENV === 'production') {\n                    // Use console directly to display this warning without bloating\n                    // bundle sizes by pulling in all of the logger codebase in prod.\n                    console.warn(warningMessage);\n                }\n                else {\n                    logger.warn(warningMessage);\n                }\n            }\n        }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.InstallResult>}\n     */\n    install(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n            const installReportPlugin = new PrecacheInstallReportPlugin();\n            this.strategy.plugins.push(installReportPlugin);\n            // Cache entries one at a time.\n            // See https://github.com/GoogleChrome/workbox/issues/2528\n            for (const [url, cacheKey] of this._urlsToCacheKeys) {\n                const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n                const cacheMode = this._urlsToCacheModes.get(url);\n                const request = new Request(url, {\n                    integrity,\n                    cache: cacheMode,\n                    credentials: 'same-origin',\n                });\n                await Promise.all(this.strategy.handleAll({\n                    params: { cacheKey },\n                    request,\n                    event,\n                }));\n            }\n            const { updatedURLs, notUpdatedURLs } = installReportPlugin;\n            if (process.env.NODE_ENV !== 'production') {\n                printInstallDetails(updatedURLs, notUpdatedURLs);\n            }\n            return { updatedURLs, notUpdatedURLs };\n        });\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.CleanupResult>}\n     */\n    activate(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            const currentlyCachedRequests = await cache.keys();\n            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n            const deletedURLs = [];\n            for (const request of currentlyCachedRequests) {\n                if (!expectedCacheKeys.has(request.url)) {\n                    await cache.delete(request);\n                    deletedURLs.push(request.url);\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                printCleanupDetails(deletedURLs);\n            }\n            return { deletedURLs };\n        });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n    getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n    getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n    getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * @param {string} url A cache key whose SRI you want to look up.\n     * @return {string} The subresource integrity associated with the cache key,\n     * or undefined if it's not set.\n     */\n    getIntegrityForCacheKey(cacheKey) {\n        return this._cacheKeysToIntegrities.get(cacheKey);\n    }\n    /**\n     * This acts as a drop-in replacement for\n     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @return {workbox-routing~handlerCallback}\n     */\n    createHandlerBoundToURL(url) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n            throw new WorkboxError('non-precached-url', { url });\n        }\n        return (options) => {\n            options.request = new Request(url);\n            options.params = Object.assign({ cacheKey }, options.params);\n            return this.strategy.handle(options);\n        };\n    }\n}\nexport { PrecacheController };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}