{"ast":null,"code":"/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof workbox-strategies\n */\n\nclass Strategy {\n  /**\n   * Creates a new instance of the strategy and sets all documented option\n   * properties as public instance properties.\n   *\n   * Note: if a custom strategy class extends the base Strategy class and does\n   * not need more than these properties, it does not need to define its own\n   * constructor.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to the cache names provided by\n   * {@link workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n   * `fetch()` requests made by this strategy.\n   * @param {Object} [options.matchOptions] The\n   * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /**\n     * Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     *\n     * @type {string}\n     */\n    this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n    /**\n     * The list\n     * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * used by this strategy.\n     *\n     * @type {Array<Object>}\n     */\n\n    this.plugins = options.plugins || [];\n    /**\n     * Values passed along to the\n     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n     * of all fetch() requests made by this strategy.\n     *\n     * @type {Object}\n     */\n\n    this.fetchOptions = options.fetchOptions;\n    /**\n     * The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     *\n     * @type {Object}\n     */\n\n    this.matchOptions = options.matchOptions;\n  }\n  /**\n   * Perform a request strategy and returns a `Promise` that will resolve with\n   * a `Response`, invoking all relevant plugin callbacks.\n   *\n   * When a strategy instance is registered with a Workbox\n   * {@link workbox-routing.Route}, this method is automatically\n   * called when the route matches.\n   *\n   * Alternatively, this method can be used in a standalone `FetchEvent`\n   * listener by passing it to `event.respondWith()`.\n   *\n   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n   *     properties listed below.\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params]\n   */\n\n\n  handle(options) {\n    const [responseDone] = this.handleAll(options);\n    return responseDone;\n  }\n  /**\n   * Similar to {@link workbox-strategies.Strategy~handle}, but\n   * instead of just returning a `Promise` that resolves to a `Response` it\n   * it will return an tuple of `[response, done]` promises, where the former\n   * (`response`) is equivalent to what `handle()` returns, and the latter is a\n   * Promise that will resolve once any promises that were added to\n   * `event.waitUntil()` as part of performing the strategy have completed.\n   *\n   * You can await the `done` promise to ensure any extra work performed by\n   * the strategy (usually caching responses) completes successfully.\n   *\n   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n   *     properties listed below.\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params]\n   * @return {Array<Promise>} A tuple of [response, done]\n   *     promises that can be used to determine when the response resolves as\n   *     well as when the handler has completed all its work.\n   */\n\n\n  handleAll(options) {\n    // Allow for flexible options to be passed.\n    if (options instanceof FetchEvent) {\n      options = {\n        event: options,\n        request: options.request\n      };\n    }\n\n    const event = options.event;\n    const request = typeof options.request === 'string' ? new Request(options.request) : options.request;\n    const params = 'params' in options ? options.params : undefined;\n    const handler = new StrategyHandler(this, {\n      event,\n      request,\n      params\n    });\n\n    const responseDone = this._getResponse(handler, request, event);\n\n    const handlerDone = this._awaitComplete(responseDone, handler, request, event); // Return an array of promises, suitable for use with Promise.all().\n\n\n    return [responseDone, handlerDone];\n  }\n\n  async _getResponse(handler, request, event) {\n    await handler.runCallbacks('handlerWillStart', {\n      event,\n      request\n    });\n    let response = undefined;\n\n    try {\n      response = await this._handle(request, handler); // The \"official\" Strategy subclasses all throw this error automatically,\n      // but in case a third-party Strategy doesn't, ensure that we have a\n      // consistent failure when there's no response or an error response.\n\n      if (!response || response.type === 'error') {\n        throw new WorkboxError('no-response', {\n          url: request.url\n        });\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        for (const callback of handler.iterateCallbacks('handlerDidError')) {\n          response = await callback({\n            error,\n            event,\n            request\n          });\n\n          if (response) {\n            break;\n          }\n        }\n      }\n\n      if (!response) {\n        throw error;\n      } else if (process.env.NODE_ENV !== 'production') {\n        logger.log(\"While responding to '\".concat(getFriendlyURL(request.url), \"', \") + \"an \".concat(error instanceof Error ? error.toString() : '', \" error occurred. Using a fallback response provided by \") + \"a handlerDidError plugin.\");\n      }\n    }\n\n    for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n      response = await callback({\n        event,\n        request,\n        response\n      });\n    }\n\n    return response;\n  }\n\n  async _awaitComplete(responseDone, handler, request, event) {\n    let response;\n    let error;\n\n    try {\n      response = await responseDone;\n    } catch (error) {// Ignore errors, as response errors should be caught via the `response`\n      // promise above. The `done` promise will only throw for errors in\n      // promises passed to `handler.waitUntil()`.\n    }\n\n    try {\n      await handler.runCallbacks('handlerDidRespond', {\n        event,\n        request,\n        response\n      });\n      await handler.doneWaiting();\n    } catch (waitUntilError) {\n      if (waitUntilError instanceof Error) {\n        error = waitUntilError;\n      }\n    }\n\n    await handler.runCallbacks('handlerDidComplete', {\n      event,\n      request,\n      response,\n      error: error\n    });\n    handler.destroy();\n\n    if (error) {\n      throw error;\n    }\n  }\n\n}\n\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the {@link workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof workbox-strategies.Strategy\n */","map":{"version":3,"names":["cacheNames","WorkboxError","logger","getFriendlyURL","StrategyHandler","Strategy","constructor","options","cacheName","getRuntimeName","plugins","fetchOptions","matchOptions","handle","responseDone","handleAll","FetchEvent","event","request","Request","params","undefined","handler","_getResponse","handlerDone","_awaitComplete","runCallbacks","response","_handle","type","url","error","Error","callback","iterateCallbacks","process","env","NODE_ENV","log","toString","doneWaiting","waitUntilError","destroy"],"sources":["C:/Users/omkar/OneDrive/Pictures/Desktop/weather/weather-app-reactjs/node_modules/workbox-strategies/Strategy.js"],"sourcesContent":["/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof workbox-strategies\n */\nclass Strategy {\n    /**\n     * Creates a new instance of the strategy and sets all documented option\n     * properties as public instance properties.\n     *\n     * Note: if a custom strategy class extends the base Strategy class and does\n     * not need more than these properties, it does not need to define its own\n     * constructor.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     */\n    constructor(options = {}) {\n        /**\n         * Cache name to store and retrieve\n         * requests. Defaults to the cache names provided by\n         * {@link workbox-core.cacheNames}.\n         *\n         * @type {string}\n         */\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n        /**\n         * The list\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n         * used by this strategy.\n         *\n         * @type {Array<Object>}\n         */\n        this.plugins = options.plugins || [];\n        /**\n         * Values passed along to the\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n         * of all fetch() requests made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.fetchOptions = options.fetchOptions;\n        /**\n         * The\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.matchOptions = options.matchOptions;\n    }\n    /**\n     * Perform a request strategy and returns a `Promise` that will resolve with\n     * a `Response`, invoking all relevant plugin callbacks.\n     *\n     * When a strategy instance is registered with a Workbox\n     * {@link workbox-routing.Route}, this method is automatically\n     * called when the route matches.\n     *\n     * Alternatively, this method can be used in a standalone `FetchEvent`\n     * listener by passing it to `event.respondWith()`.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     */\n    handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n    }\n    /**\n     * Similar to {@link workbox-strategies.Strategy~handle}, but\n     * instead of just returning a `Promise` that resolves to a `Response` it\n     * it will return an tuple of `[response, done]` promises, where the former\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\n     * Promise that will resolve once any promises that were added to\n     * `event.waitUntil()` as part of performing the strategy have completed.\n     *\n     * You can await the `done` promise to ensure any extra work performed by\n     * the strategy (usually caching responses) completes successfully.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     * @return {Array<Promise>} A tuple of [response, done]\n     *     promises that can be used to determine when the response resolves as\n     *     well as when the handler has completed all its work.\n     */\n    handleAll(options) {\n        // Allow for flexible options to be passed.\n        if (options instanceof FetchEvent) {\n            options = {\n                event: options,\n                request: options.request,\n            };\n        }\n        const event = options.event;\n        const request = typeof options.request === 'string'\n            ? new Request(options.request)\n            : options.request;\n        const params = 'params' in options ? options.params : undefined;\n        const handler = new StrategyHandler(this, { event, request, params });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        // Return an array of promises, suitable for use with Promise.all().\n        return [responseDone, handlerDone];\n    }\n    async _getResponse(handler, request, event) {\n        await handler.runCallbacks('handlerWillStart', { event, request });\n        let response = undefined;\n        try {\n            response = await this._handle(request, handler);\n            // The \"official\" Strategy subclasses all throw this error automatically,\n            // but in case a third-party Strategy doesn't, ensure that we have a\n            // consistent failure when there's no response or an error response.\n            if (!response || response.type === 'error') {\n                throw new WorkboxError('no-response', { url: request.url });\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                for (const callback of handler.iterateCallbacks('handlerDidError')) {\n                    response = await callback({ error, event, request });\n                    if (response) {\n                        break;\n                    }\n                }\n            }\n            if (!response) {\n                throw error;\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +\n                    `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` +\n                    `a handlerDidError plugin.`);\n            }\n        }\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n            response = await callback({ event, request, response });\n        }\n        return response;\n    }\n    async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n            response = await responseDone;\n        }\n        catch (error) {\n            // Ignore errors, as response errors should be caught via the `response`\n            // promise above. The `done` promise will only throw for errors in\n            // promises passed to `handler.waitUntil()`.\n        }\n        try {\n            await handler.runCallbacks('handlerDidRespond', {\n                event,\n                request,\n                response,\n            });\n            await handler.doneWaiting();\n        }\n        catch (waitUntilError) {\n            if (waitUntilError instanceof Error) {\n                error = waitUntilError;\n            }\n        }\n        await handler.runCallbacks('handlerDidComplete', {\n            event,\n            request,\n            response,\n            error: error,\n        });\n        handler.destroy();\n        if (error) {\n            throw error;\n        }\n    }\n}\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the {@link workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof workbox-strategies.Strategy\n */\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,UAAT,QAA2B,qCAA3B;AACA,SAASC,YAAT,QAA6B,uCAA7B;AACA,SAASC,MAAT,QAAuB,iCAAvB;AACA,SAASC,cAAT,QAA+B,yCAA/B;AACA,SAASC,eAAT,QAAgC,sBAAhC;AACA,OAAO,eAAP;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,QAAN,CAAe;EACX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,WAAW,GAAe;IAAA,IAAdC,OAAc,uEAAJ,EAAI;;IACtB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,KAAKC,SAAL,GAAiBR,UAAU,CAACS,cAAX,CAA0BF,OAAO,CAACC,SAAlC,CAAjB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKE,OAAL,GAAeH,OAAO,CAACG,OAAR,IAAmB,EAAlC;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,YAAL,GAAoBJ,OAAO,CAACI,YAA5B;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,KAAKC,YAAL,GAAoBL,OAAO,CAACK,YAA5B;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,MAAM,CAACN,OAAD,EAAU;IACZ,MAAM,CAACO,YAAD,IAAiB,KAAKC,SAAL,CAAeR,OAAf,CAAvB;IACA,OAAOO,YAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,SAAS,CAACR,OAAD,EAAU;IACf;IACA,IAAIA,OAAO,YAAYS,UAAvB,EAAmC;MAC/BT,OAAO,GAAG;QACNU,KAAK,EAAEV,OADD;QAENW,OAAO,EAAEX,OAAO,CAACW;MAFX,CAAV;I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"},"metadata":{},"sourceType":"module"}