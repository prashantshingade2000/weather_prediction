{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox-expiration\n */\n\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n   * that will be used when calling `delete()` on the cache.\n   */\n  constructor(cacheName) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._isRunning = false;\n    this._rerunRequested = false;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName'\n      });\n\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor'\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries'\n        });\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds'\n        });\n      }\n    }\n\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._matchOptions = config.matchOptions;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n\n\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n\n    this._isRunning = true;\n    const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n    const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries); // Delete URLs from the cache\n\n    const cache = await self.caches.open(this._cacheName);\n\n    for (const url of urlsExpired) {\n      await cache.delete(url, this._matchOptions);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (urlsExpired.length > 0) {\n        logger.groupCollapsed(\"Expired \".concat(urlsExpired.length, \" \") + \"\".concat(urlsExpired.length === 1 ? 'entry' : 'entries', \" and removed \") + \"\".concat(urlsExpired.length === 1 ? 'it' : 'them', \" from the \") + \"'\".concat(this._cacheName, \"' cache.\"));\n        logger.log(\"Expired the following \".concat(urlsExpired.length === 1 ? 'URL' : 'URLs', \":\"));\n        urlsExpired.forEach(url => logger.log(\"    \".concat(url)));\n        logger.groupEnd();\n      } else {\n        logger.debug(\"Cache expiration ran and found no entries to remove.\");\n      }\n    }\n\n    this._isRunning = false;\n\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      dontWaitFor(this.expireEntries());\n    }\n  }\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n\n\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url'\n      });\n    }\n\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n\n\n  async isURLExpired(url) {\n    if (!this._maxAgeSeconds) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new WorkboxError(\"expired-test-without-max-age\", {\n          methodName: 'isURLExpired',\n          paramName: 'maxAgeSeconds'\n        });\n      }\n\n      return false;\n    } else {\n      const timestamp = await this._timestampModel.getTimestamp(url);\n      const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n      return timestamp !== undefined ? timestamp < expireOlderThan : true;\n    }\n  }\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n\n\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n\n}\n\nexport { CacheExpiration };","map":{"version":3,"names":["assert","dontWaitFor","logger","WorkboxError","CacheTimestampsModel","CacheExpiration","constructor","cacheName","config","_isRunning","_rerunRequested","process","env","NODE_ENV","isType","moduleName","className","funcName","paramName","maxEntries","maxAgeSeconds","_maxEntries","_maxAgeSeconds","_matchOptions","matchOptions","_cacheName","_timestampModel","expireEntries","minTimestamp","Date","now","urlsExpired","cache","self","caches","open","url","delete","length","groupCollapsed","log","forEach","groupEnd","debug","updateTimestamp","setTimestamp","isURLExpired","methodName","timestamp","getTimestamp","expireOlderThan","undefined","Infinity"],"sources":["C:/Users/omkar/OneDrive/Pictures/Desktop/weather/weather-app-reactjs/node_modules/workbox-expiration/CacheExpiration.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox-expiration\n */\nclass CacheExpiration {\n    /**\n     * To construct a new CacheExpiration instance you must provide at least\n     * one of the `config` properties.\n     *\n     * @param {string} cacheName Name of the cache to apply restrictions to.\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n     * that will be used when calling `delete()` on the cache.\n     */\n    constructor(cacheName, config = {}) {\n        this._isRunning = false;\n        this._rerunRequested = false;\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(cacheName, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'constructor',\n                paramName: 'cacheName',\n            });\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n            }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._matchOptions = config.matchOptions;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n    }\n    /**\n     * Expires entries for the given cache and given criteria.\n     */\n    async expireEntries() {\n        if (this._isRunning) {\n            this._rerunRequested = true;\n            return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds\n            ? Date.now() - this._maxAgeSeconds * 1000\n            : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        // Delete URLs from the cache\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired) {\n            await cache.delete(url, this._matchOptions);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (urlsExpired.length > 0) {\n                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +\n                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n                    `'${this._cacheName}' cache.`);\n                logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n                urlsExpired.forEach((url) => logger.log(`    ${url}`));\n                logger.groupEnd();\n            }\n            else {\n                logger.debug(`Cache expiration ran and found no entries to remove.`);\n            }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n            this._rerunRequested = false;\n            dontWaitFor(this.expireEntries());\n        }\n    }\n    /**\n     * Update the timestamp for the given URL. This ensures the when\n     * removing entries based on maximum entries, most recently used\n     * is accurate or when expiring, the timestamp is up-to-date.\n     *\n     * @param {string} url\n     */\n    async updateTimestamp(url) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(url, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'updateTimestamp',\n                paramName: 'url',\n            });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n    }\n    /**\n     * Can be used to check if a URL has expired or not before it's used.\n     *\n     * This requires a look up from IndexedDB, so can be slow.\n     *\n     * Note: This method will not remove the cached entry, call\n     * `expireEntries()` to remove indexedDB and Cache entries.\n     *\n     * @param {string} url\n     * @return {boolean}\n     */\n    async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n            if (process.env.NODE_ENV !== 'production') {\n                throw new WorkboxError(`expired-test-without-max-age`, {\n                    methodName: 'isURLExpired',\n                    paramName: 'maxAgeSeconds',\n                });\n            }\n            return false;\n        }\n        else {\n            const timestamp = await this._timestampModel.getTimestamp(url);\n            const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n            return timestamp !== undefined ? timestamp < expireOlderThan : true;\n        }\n    }\n    /**\n     * Removes the IndexedDB object store used to keep track of cache expiration\n     * metadata.\n     */\n    async delete() {\n        // Make sure we don't attempt another rerun if we're called in the middle of\n        // a cache expiration.\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\n    }\n}\nexport { CacheExpiration };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}